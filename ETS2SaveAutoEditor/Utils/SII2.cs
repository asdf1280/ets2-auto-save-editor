using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Shapes;
using System.Xml.Linq;
using Windows.Foundation.Metadata;

namespace ETS2SaveAutoEditor.Utils {
    /// <summary>
    /// A next-generation SII file parser. The key difference is that this parser decodes the whole file to the memory, unlike the old parser which kept the data line by line in SII string.
    /// </summary>
    public class SII2 : IList<Unit2>, IReadOnlyDictionary<string, Unit2> {
        internal readonly List<Unit2> units = [];
        internal readonly Dictionary<string, Unit2> unitMap = [];

        public const string Indent = " ";
        private static bool countArrays = false;
        public static bool CountArrays {
            get => countArrays;
            set {
                countArrays = value;
            }
        }

        private enum SIIOpenStage {
            NotOpened,
            MagicNumberRead,
            Ready,
            Unit,
            Finished
        }

        /// <summary>
        /// Creates a new SII2 instance based on the given lines. Note that this parser doesn't support comments. It's intended to read SIIs generated by the game, not from the user or modders. @include isn't supported.
        /// </summary>
        /// <param name="lines">SII file lines</param>
        /// <exception cref="ArgumentException">Invalid SII file format.</exception>
        [SuppressMessage("Performance", "SYSLIB1045:Convert to 'GeneratedRegexAttribute'.", Justification = "Doesn't affect performance greatly. Would rather complicate the source code.")]
        private SII2(IEnumerable<string> lines) {
            SIIOpenStage siiOpenStage = SIIOpenStage.NotOpened;
            Unit2? currentUnit = null;
            string? currentKey = null;
            Value2? currentValue = null;

            var p = new Regex(@"^([a-z_]+) : ([_\-\.a-zA-Z0-9]+) {$", RegexOptions.Compiled);
            var p1 = new Regex(@"^(.*?)(\[\d*\])?: (.*)", RegexOptions.Compiled); // Regex.Match(line, $"^\\s+{name}\\[\\d*\\]: (.*)$");

            int ln = 0;
            foreach (string line in lines) {
                ++ln;
                var s = line.Trim();
                if (s.Length == 0) continue;
                if (siiOpenStage == SIIOpenStage.NotOpened) {
                    if (s != "SiiNunit") {
                        throw new ArgumentException("The file is not a valid SII file at line " + ln + ".");
                    }
                    siiOpenStage = SIIOpenStage.MagicNumberRead;
                    continue;
                } else if (siiOpenStage == SIIOpenStage.MagicNumberRead) {
                    if (s != "{") {
                        throw new ArgumentException("The file is not a valid SII file at line " + ln + ".");
                    }
                    siiOpenStage = SIIOpenStage.Ready;
                    continue;
                } else if (siiOpenStage == SIIOpenStage.Ready) {
                    if (s == "}") {
                        siiOpenStage = SIIOpenStage.Finished;
                        break;
                    }
                    var match = p.Match(s);
                    if (!match.Success) {
                        throw new ArgumentException("The file is not a valid SII file at line " + ln + ".");
                    }
                    currentUnit = new(match.Groups[1].Value, match.Groups[2].Value);
                    currentKey = null;
                    currentValue = null;
                    siiOpenStage = SIIOpenStage.Unit;
                } else if (siiOpenStage == SIIOpenStage.Unit) {
                    if (s == "}") { // The unit is closed.
                        // Save previous entry into the currentUnit
                        if (currentKey is not null) // Empty unit
                            currentUnit![currentKey] = currentValue!;

                        currentUnit!.Attach(this);
                        siiOpenStage = SIIOpenStage.Ready;
                        continue;
                    }
                    var match = p1.Match(s);
                    if (!match.Success) {
                        throw new ArgumentException("The file is not a valid SII file at line " + ln + ".");
                    }
                    string key = match.Groups[1].Value;
                    bool isArrayElement = match.Groups[2].Value.Length > 0;
                    string value = match.Groups[3].Value;

                    if (key != currentKey) {
                        // Save previous entry into the currentUnit
                        if (currentKey is not null)
                            currentUnit![currentKey] = currentValue!;

                        // Create a new entry
                        currentKey = key;
                        if (isArrayElement)
                            currentValue = new RawDataArrayValue2([value]);
                        else
                            currentValue = new RawDataValue2(value);
                    } else if (isArrayElement) {
                        if (key == currentKey) { // Append to the current array. Throw if the key doesn't match
                            if (currentValue is not RawDataArrayValue2) // Current value is size of the array.
                                currentValue = new RawDataArrayValue2();

                            ((RawDataArrayValue2)currentValue).TypedValue.Add(value); // Append to the array.
                        }
                    } else { // Throw. Multiple non-array elements with the same key.
                        throw new ArgumentException("The file is not a valid SII file at line " + ln + ".");
                    }
                }
            }
        }

        public SII2(string fullText) : this(fullText.Split('\n')) { }

        #region IList<Unit2> and IReadOnlyDictionary<string, Unit2> implementation
        public Unit2 this[int index] {
            get {
                return units[index];
            }
            set {
                if (value == null) {
                    throw new ArgumentNullException(nameof(value));
                }

                // remove the old item.
                RemoveAt(index);

                Insert(index, value);
            }
        }

        Unit2 IReadOnlyDictionary<string, Unit2>.this[string key] {
            get {
                if (unitMap.TryGetValue(key, out Unit2? value)) {
                    return value;
                } else {
                    throw new KeyNotFoundException();
                }
            }
        }

        public int Count => units.Count;

        public bool IsReadOnly => false;

        IEnumerable<string> IReadOnlyDictionary<string, Unit2>.Keys => throw new NotImplementedException();

        IEnumerable<Unit2> IReadOnlyDictionary<string, Unit2>.Values => throw new NotImplementedException();

        int IReadOnlyCollection<KeyValuePair<string, Unit2>>.Count => throw new NotImplementedException();

        public void Add(Unit2 item) {
            units.Add(item);
            unitMap[item.Id] = item;
        }

        public void Clear() {
            foreach (var unit in units) {
                unit.Detach();
            }
            units.Clear();
            unitMap.Clear();
        }

        public bool Contains(Unit2 item) {
            return unitMap.ContainsValue(item);
        }

        public void CopyTo(Unit2[] array, int arrayIndex) {
            units.CopyTo(array, arrayIndex);
        }

        public IEnumerator<Unit2> GetEnumerator() {
            return units.GetEnumerator();
        }

        public int IndexOf(Unit2 item) {
            return units.IndexOf(item);
        }

        public void Insert(int index, Unit2 item) {
            units.Insert(index, item);
            unitMap[item.Id] = item;
        }

        public bool Remove(Unit2 item) {
            if (!units.Contains(item)) {
                return false;
            }
            item.Detach();
            return units.Remove(item) || unitMap.Remove(item.Id);
        }

        public void RemoveAt(int index) {
            var item = units[index];
            Remove(item);
        }

        bool IReadOnlyDictionary<string, Unit2>.ContainsKey(string key) {
            return unitMap.ContainsKey(key);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return units.GetEnumerator();
        }

        IEnumerator<KeyValuePair<string, Unit2>> IEnumerable<KeyValuePair<string, Unit2>>.GetEnumerator() {
            return unitMap.GetEnumerator();
        }

        bool IReadOnlyDictionary<string, Unit2>.TryGetValue(string key, [MaybeNullWhen(false)] out Unit2 value) {
            return unitMap.TryGetValue(key, out value);
        }
        #endregion

        public void WriteTo(StreamWriter writer) {
            writer.Write("SiiNunit\n{\n");

            foreach(var unit in units) {
                unit.WriteTo(writer);
                writer.Write("\n"); // extra line between units
            }

            writer.Write("}\n");
        }
    }

    public enum Type2 {
        Raw,
        RawArray
    }

    public class Unit2 : IReadOnlyList<string>, IDictionary<string, Value2> {
        private SII2? parent = null;
        private string type;
        private string id;

        internal readonly List<string> keys = [];
        internal readonly Dictionary<string, Value2> valueMap = [];

        internal Unit2(string type, string id) {
            this.type = type;
            this.id = id;
        }

        internal void Detach() {
            parent = null;
        }

        public void Attach(SII2 parent) {
            if (this.parent != null) {
                throw new InvalidOperationException("This unit is already attached to a SII2 instance.");
            }

            this.parent = parent;
            parent.Add(this);
        }

        #region IReadOnlyList<string> and IDictionary<string, Value2<object>> implementation
        public IEnumerator<string> GetEnumerator() {
            return keys.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return keys.GetEnumerator();
        }

        public void Add(string key, Value2 value) {
            if (valueMap.ContainsKey(key)) {
                throw new ArgumentException("An item with the same key has already been added.");
            }

            keys.Add(key);
            valueMap[key] = value;
        }

        public bool ContainsKey(string key) {
            return valueMap.ContainsKey(key);
        }

        public bool Remove(string key) {
            return keys.Remove(key) || valueMap.Remove(key);
        }

        public bool TryGetValue(string key, [MaybeNullWhen(false)] out Value2 value) {
            return valueMap.TryGetValue(key, out value);
        }

        public void Add(KeyValuePair<string, Value2> item) {
            Add(item.Key, item.Value);
        }

        public void Clear() {
            keys.Clear();
            valueMap.Clear();
        }

        public bool Contains(KeyValuePair<string, Value2> item) {
            return valueMap.Contains(item);
        }

        [Deprecated("This method is not supported.", DeprecationType.Remove, 1)]
        public void CopyTo(KeyValuePair<string, Value2>[] array, int arrayIndex) {
            throw new NotImplementedException();
        }

        public bool Remove(KeyValuePair<string, Value2> item) {
            if (valueMap.Contains(item)) {
                keys.Remove(item.Key);
                return valueMap.Remove(item.Key);
            } else {
                return false;
            }
        }

        IEnumerator<KeyValuePair<string, Value2>> IEnumerable<KeyValuePair<string, Value2>>.GetEnumerator() {
            return valueMap.GetEnumerator();
        }

        public Value2 this[string key] {
            get {
                if (valueMap.TryGetValue(key, out Value2? value)) {
                    return value;
                } else {
                    throw new KeyNotFoundException();
                }
            }
            set {
                ArgumentNullException.ThrowIfNull(value);

                if (valueMap.ContainsKey(key)) {
                    valueMap[key] = value;
                } else {
                    keys.Add(key);
                    valueMap[key] = value;
                }
            }
        }

        public int Count => keys.Count;

        public bool IsReadOnly => false;

        public ICollection<string> Keys => valueMap.Keys;

        public ICollection<Value2> Values => valueMap.Values;

        public string this[int index] {
            get {
                return keys[index];
            }
        }

        #endregion

        public bool IsDetached {
            get {
                return parent == null;
            }
        }

        public string Type {
            get {
                return type;
            }
            set {
                ArgumentNullException.ThrowIfNull(value);

                type = value;
            }
        }

        public string Id {
            get {
                return id;
            }
            set {
                if (parent != null)
                    parent.unitMap.Remove(id);
                id = value;
                if (parent != null)
                    parent.unitMap[id] = this;
            }
        }

        public void WriteTo(StreamWriter writer) {
            writer.Write(type + " : " + id + " {\n");

            var keysInMap = valueMap.Keys.ToHashSet();
            List<string> keys = new(this.keys);
            foreach (var k in keysInMap) {
                if (!keys.Contains(k)) {
                    keys.Add(k);
                }
            }

            foreach (var key in keys) {
                if (valueMap.TryGetValue(key, out Value2? value)) {
                    value.WriteTo(writer, key);
                }
            }

            writer.Write("}\n");
        }
    }

    public abstract class Value2 {
        public abstract void WriteTo(StreamWriter writer, string key);

        public abstract object Value { get; }
    }

    public abstract class Value2<T> : Value2 {
        public abstract T TypedValue { get; }
    }

    public abstract class ValueArray2<T> : Value2<List<T>> {
    }

    public class RawDataValue2 : Value2<string> {
        private string rawstr;

        public RawDataValue2(string value) {
            rawstr = value;
        }

        public RawDataValue2(Value2 value2) : this(value2.Value.ToString() ?? "null") { }

        public RawDataValue2() {
            rawstr = "null";
        }

        public override string Value => rawstr;

        public override string TypedValue => rawstr;

        public void SetValue(string value) {
            rawstr = value;
        }

        public override void WriteTo(StreamWriter writer, string key) {
            writer.Write(SII2.Indent + key + ": " + rawstr + "\n");
        }

        public override string ToString() {
            return rawstr;
        }
    }

    public class RawDataArrayValue2 : ValueArray2<string> {
        private readonly List<string> data;

        public override List<string> Value => data;
        public override List<string> TypedValue => data;

        public RawDataArrayValue2(IEnumerable<string> d) {
            data = new(d);
        }

        public RawDataArrayValue2() : this([]) { }
        public RawDataArrayValue2(Value2 d) {
            if (d.Value is string and "0") {
                data = [];
            } else if (d is ValueArray2<string> d2) {
                data = d2.TypedValue.Select(x => x.ToString() ?? "null").ToList(); // <- HERE
            } else {
                throw new ArgumentException("The value is not an array.");
            }
        }

        public RawDataArrayValue2(ValueArray2<object> d) : this((Value2)d) { }

        public override void WriteTo(StreamWriter writer, string key) {
            if (SII2.CountArrays) {
                writer.Write(SII2.Indent + key + ": " + data.Count + "\n");
            }
            for (int i = 0; i < data.Count; i++) {
                if (SII2.CountArrays)
                    writer.Write(SII2.Indent + key + "[" + i + "]: " + data[i] + "\n");
                else
                    writer.Write(SII2.Indent + key + "[]: " + data[i] + "\n");
            }
        }

        public override string ToString() {
            StringBuilder sb = new();
            sb.Append(nameof(RawDataArrayValue2));
            foreach (var d in data) {
                sb.Append("\n\t" + d);
            }
            return sb.ToString();
        }
    }
}